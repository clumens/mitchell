%name Mitchell;

%tokens
   : ABSORB | ASSIGN | BOOLEAN of bool | BOTTOM | CASE | COLON | COMMA |
     DBLQUOTE | DECL | DOT | ELSE | END | EXN | FUNCTION |
     HANDLE | IDENTIFIER of BaseTy.mstring | IF | IN | INTEGER of int |
     LBRACE | LBRACK | LIST | LPAREN | MAPSTO | MODULE | PIPE | RAISE |
     RBRACE | RBRACK | RPAREN | SEMICOLON | STRING of BaseTy.mstring |
     THEN | TYPE | UNION | VAL
   ;

%defs (
   (* A span gives us both the start and ending position, but we really only
    * care about the start.
    *)
   fun span2pos (span: StreamPos.span) = #1 span
);

(* START *)

module_decl:
   MODULE IDENTIFIER ASSIGN DECL top_decl+ END =>
      ( Absyn.ModuleDecl{sym=Symbol.toSymbol (IDENTIFIER, Symbol.MODULE), decls=top_decl,
                         pos=span2pos MODULE_SPAN, symtab=Symtab.mkTable()}
      );


(* EXPRESSIONS *)

expr:
   LPAREN base_expr RPAREN handle_expr? =>
      ( Absyn.Expr{expr=base_expr, pos=span2pos LPAREN_SPAN, ty=NONE,
                   exnHandler=handle_expr} )
 | base_expr => ( Absyn.Expr{expr=base_expr, pos=span2pos base_expr_SPAN, ty=NONE,
                             exnHandler=NONE} );

base_expr:
   record_literal          => ( record_literal )
 | LBRACK expr_lst? RBRACK => ( Absyn.ExprLstExp (Option.getOpt (expr_lst, [])))
 | case_expr               => ( case_expr )
 | decl_expr               => ( decl_expr )
 | if_expr                 => ( if_expr )
 | sym_ref                 => ( sym_ref )
 | RAISE expr              => ( Absyn.RaiseExp expr )
 | INTEGER                 => ( Absyn.IntegerExp INTEGER )
 | STRING                  => ( Absyn.StringExp STRING )
 | BOOLEAN                 => ( Absyn.BooleanExp BOOLEAN )
 | BOTTOM                  => ( Absyn.BottomExp );

record_literal:
   LBRACE record_assn_lst RBRACE => ( Absyn.RecordAssnExp record_assn_lst );

record_assn_lst:
   single_record_assn (COMMA single_record_assn)* => ( [single_record_assn] @ SR );

single_record_assn:
   IDENTIFIER ASSIGN expr => ( (Symbol.toSymbol (IDENTIFIER, Symbol.VALUE), expr) );

expr_lst:
   expr (COMMA expr)* => ( [expr] @ SR );

case_expr:
   CASE expr IN branch_lst (COMMA ELSE MAPSTO expr)? END =>
      ( Absyn.CaseExp{test=expr, branches=branch_lst, default=SR} );

branch_lst:
   single_branch (COMMA single_branch)* => ( [single_branch] @ SR );

single_branch:
   branch_expr MAPSTO expr => ( (branch_expr, expr) );

branch_expr:
   id (LPAREN name_lst? RPAREN)? =>
      ( let val syms = Option.getOpt (Option.getOpt (SR, NONE), [])
        in Absyn.UnionBranch (id, syms, Symtab.mkTable())
        end
      )
 | INTEGER  => ( Absyn.RegularBranch (Absyn.IntegerExp INTEGER) )
 | STRING   => ( Absyn.RegularBranch (Absyn.StringExp STRING) )
 | BOOLEAN  => ( Absyn.RegularBranch (Absyn.BooleanExp BOOLEAN) );

decl_expr:
   DECL decl+ IN expr END => ( Absyn.DeclExp{decls=decl, expr=expr,
                                             symtab=Symtab.mkTable()} );

if_expr:
   IF expr THEN expr ELSE expr => ( Absyn.IfExp{test=expr1, then'=expr2, else'=expr3} );

sym_ref:
   id complex_sym_ref@(id)? (PIPE IDENTIFIER)* =>
      ( let val expr = Option.getOpt(complex_sym_ref, Absyn.IdExp id)
        in
           if List.null SR then expr
           else Absyn.RecordRefExp{record=expr,
                                   ele=map (fn s => Symbol.toSymbol (s, Symbol.VALUE)) SR}
        end
      );

complex_sym_ref(id):
   LPAREN ty (COMMA ty)* SEMICOLON expr_lst? RPAREN =>
      ( Absyn.FunCallExp{id=id, tyArgs=[ty] @ SR, args=Option.getOpt(expr_lst, []),
                         frees=[]}
      )
 | record_literal => ( record_literal );


(* EXCEPTIONS *)

handle_expr:
   HANDLE ELSE IDENTIFIER MAPSTO expr END =>
      ( {handlers=[], ty=NONE, pos=span2pos HANDLE_SPAN,
         default=SOME (Absyn.ExnHandler{exnKind=NONE, expr=expr, ty=NONE,
                                        pos=span2pos IDENTIFIER_SPAN,
                                        sym=Symbol.toSymbol (IDENTIFIER, Symbol.EXN_TYPE),
                                        symtab=Symtab.mkTable()})} )
 | HANDLE exn_lst (COMMA ELSE IDENTIFIER MAPSTO expr =>
                     ( Absyn.ExnHandler{exnKind=NONE, expr=expr, ty=NONE,
                                        pos=span2pos ELSE_SPAN,
                                        sym=Symbol.toSymbol (IDENTIFIER, Symbol.EXN_TYPE),
                                        symtab=Symtab.mkTable()}
                     )
                  )? END =>
      ( {handlers=exn_lst, default=SR, ty=NONE, pos=span2pos HANDLE_SPAN} );

exn_lst:
   single_exn (COMMA single_exn)* => ( [single_exn] @ SR );

single_exn:
   id IDENTIFIER MAPSTO expr =>
      ( Absyn.ExnHandler{exnKind=SOME id, expr=expr, pos=span2pos id_SPAN, 
                         sym=Symbol.toSymbol (IDENTIFIER, Symbol.EXN_TYPE),
                         symtab=Symtab.mkTable(), ty=NONE}
      );


(* IDENTIFIERS *)

id:
   IDENTIFIER (DOT IDENTIFIER)* => ( Absyn.Id ([IDENTIFIER] @ SR) );

(* FIXME: broken for the list case *)
name_lst:
   IDENTIFIER (COMMA IDENTIFIER)* => ( [Symbol.toSymbol (IDENTIFIER, Symbol.VALUE)] );
(*
   IDENTIFIER (COMMA IDENTIFIER)* => ( (Symbol.toSymbol (IDENTIFIER, Symbol.VALUE))::SR );
*)

typed_name_lst:
   typed_name (COMMA typed_name)* => ( [typed_name] @ SR );

typed_name:
   IDENTIFIER COLON ty => ( (Symbol.toSymbol (IDENTIFIER, Symbol.VALUE), ty,
                             span2pos IDENTIFIER_SPAN) );


(* DECLARATIONS *)

decl:
   ABSORB id   => ( Absyn.Absorb{module=id, pos=span2pos ABSORB_SPAN} )
 | fun_decl    => ( fun_decl )
 | ty_decl     => ( ty_decl )
 | val_decl    => ( val_decl );

fun_decl:
   FUNCTION IDENTIFIER LPAREN ty_formals_lst SEMICOLON formals_lst RPAREN (COLON ty)? ASSIGN expr =>
      ( Absyn.FunDecl{sym=Symbol.toSymbol (IDENTIFIER, Symbol.FUN_TYCON), retval=SR,
                      pos=span2pos FUNCTION_SPAN, formals=formals_lst,
                      tyFormals=ty_formals_lst, calls=[], body=expr,
                      symtab=Symtab.mkTable()}
      );

formals_lst:
   typed_name_lst? => ( Option.getOpt (typed_name_lst, []) );

top_decl:
   decl        => ( decl )
 | module_decl => ( module_decl );

ty_decl:
   TYPE IDENTIFIER (LPAREN name_lst RPAREN)? ASSIGN ty =>
      ( Absyn.TyDecl{sym=Symbol.toSymbol (IDENTIFIER, Symbol.EXN_TYPE), ty=NONE,
                     absynTy=ty, tyvars=SR, symtab=SOME (Symtab.mkTable()),
                     pos=span2pos TYPE_SPAN}
      );

ty_formals_lst:
   name_lst? => ( Option.getOpt (name_lst, []) );

val_decl:
   VAL IDENTIFIER (COLON ty)? ASSIGN expr =>
      ( Absyn.ValDecl{sym=Symbol.toSymbol (IDENTIFIER, Symbol.VALUE), ty=NONE,
                      absynTy=SR, init=expr, pos=span2pos VAL_SPAN} );


(* TYPES *)

ty:
   BOTTOM                           => ( Absyn.BottomTy (span2pos BOTTOM_SPAN) )
 | EXN LBRACE typed_name_lst RBRACE => ( Absyn.ExnTy{exn'=typed_name_lst,
                                                     pos=span2pos EXN_SPAN} )
 | id                               => ( Absyn.IdTy{id=id, pos=span2pos id_SPAN} )
 | LBRACE typed_name_lst RBRACE     => ( Absyn.RecordTy{record=typed_name_lst,
                                                        pos=span2pos LBRACE_SPAN} )
 | LIST ty                          => ( Absyn.ListTy{lst=ty, pos=span2pos LIST_SPAN} )
 | UNION LBRACE tycon_lst RBRACE    => ( Absyn.UnionTy{tycons=tycon_lst,
                                                       pos=span2pos UNION_SPAN} );

tycon_lst:
   tycon (COMMA tycon)* => ( [tycon] @ SR );

tycon:
   IDENTIFIER (COLON ty)? => ( let val sym = Symbol.toSymbol (IDENTIFIER, Symbol.FUN_TYCON)
                               in (sym, SR, span2pos IDENTIFIER_SPAN)
                               end
                             );
