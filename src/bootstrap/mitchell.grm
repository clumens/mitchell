%name Mitchell;

%tokens
   : ABSORB | ASSIGN | BOOLEAN of bool | BOTTOM | CASE | COLON | COMMA |
     DBLQUOTE | DECL | DOT | ELSE | END | EXN | FUNCTION |
     HANDLE | IDENTIFIER of BaseTy.mstring | IF | IN | INTEGER of int |
     LBRACE | LBRACK | LIST | LPAREN | MAPSTO | MODULE | PIPE | RAISE |
     RBRACE | RBRACK | RPAREN | SEMICOLON | STRING of BaseTy.mstring |
     THEN | TYPE | UNION | VAL
   ;

%defs (
   (* A span gives us both the start and ending position, but we really only
    * care about the start.
    *)
   fun span2pos (span: StreamPos.span) = #1 span
);

(* START *)

module_decl(env):
   MODULE IDENTIFIER ASSIGN DECL top_decl@(env)+ END =>
      ( Absyn.ModuleDecl{sym=Symbol.toSymbol (IDENTIFIER, Symbol.MODULE), decls=top_decl,
                         pos=span2pos MODULE_SPAN, symtab=Symtab.mkTable()}
      );


(* EXPRESSIONS *)

expr(env):
   LPAREN base_expr@(env) RPAREN handle_expr@(env)? =>
      ( Absyn.Expr{expr=base_expr, pos=span2pos LPAREN_SPAN, ty=NONE,
                   exnHandler=handle_expr} )
 | base_expr@(env) => ( Absyn.Expr{expr=base_expr, pos=span2pos base_expr_SPAN,
                                   ty=NONE, exnHandler=NONE} );

base_expr(env):
   record_literal@(env)          => ( record_literal )
 | LBRACK expr_lst@(env)? RBRACK => ( Absyn.ExprLstExp (Option.getOpt (expr_lst, [])))
 | case_expr@(env)               => ( case_expr )
 | decl_expr@(env)               => ( decl_expr )
 | if_expr@(env)                 => ( if_expr )
 | sym_ref@(env)                 => ( Absyn.BottomExp )
 | RAISE expr@(env)              => ( Absyn.RaiseExp expr )
 | INTEGER                       => ( Absyn.IntegerExp INTEGER )
 | STRING                        => ( Absyn.StringExp STRING )
 | BOOLEAN                       => ( Absyn.BooleanExp BOOLEAN )
 | BOTTOM                        => ( Absyn.BottomExp );

record_literal(env):
   LBRACE record_assn_lst@(env) RBRACE => ( Absyn.RecordAssnExp record_assn_lst );

record_assn_lst(env):
   single_record_assn@(env) (COMMA single_record_assn@(env))* =>
      ( [single_record_assn] @ SR );

single_record_assn(env):
   IDENTIFIER ASSIGN expr@(env) =>
      ( (Symbol.toSymbol (IDENTIFIER, Symbol.VALUE), expr) );

expr_lst(env):
   expr@(env) (COMMA expr@(env))* => ( [expr] @ SR );

case_expr(env):
   CASE expr@(env) IN branch_lst@(env) (COMMA ELSE MAPSTO expr@(env))? END =>
      ( Absyn.CaseExp{test=expr, branches=branch_lst, default=SR} );

branch_lst(env):
   single_branch@(env) (COMMA single_branch@(env))* => ( [single_branch] @ SR );

single_branch(env):
   branch_expr@(env) MAPSTO expr@(env) => ( (branch_expr, expr) );

branch_expr(env):
   id@(env) (LPAREN name_lst@(env)? RPAREN)? =>
      ( let val syms = Option.getOpt (Option.getOpt (SR, NONE), [])
        in Absyn.UnionBranch (id, syms, Symtab.mkTable())
        end
      )
 | INTEGER  => ( Absyn.RegularBranch (Absyn.IntegerExp INTEGER) )
 | STRING   => ( Absyn.RegularBranch (Absyn.StringExp STRING) )
 | BOOLEAN  => ( Absyn.RegularBranch (Absyn.BooleanExp BOOLEAN) );

decl_expr(env):
   DECL decl@(env)+ IN expr@(env) END => ( Absyn.DeclExp{decls=decl, expr=expr,
                                                         symtab=Symtab.mkTable()} );

if_expr(env):
   IF expr@(env) THEN expr@(env) ELSE expr@(env) =>
      ( Absyn.IfExp{test=expr1, then'=expr2, else'=expr3} );

sym_ref(env):
   id@(env) complex_sym_ref@(env)? (PIPE IDENTIFIER)* => ();

complex_sym_ref(env):
   LPAREN ty@(env) (COMMA ty@(env))* SEMICOLON expr_lst@(env)? RPAREN => ()
 | record_literal@(env) => ();


(* EXCEPTIONS *)

handle_expr(env):
   HANDLE ELSE IDENTIFIER MAPSTO expr@(env) END =>
      ( {handlers=[], ty=NONE, pos=span2pos HANDLE_SPAN,
         default=SOME (Absyn.ExnHandler{exnKind=NONE, expr=expr, ty=NONE,
                                        pos=span2pos IDENTIFIER_SPAN,
                                        sym=Symbol.toSymbol (IDENTIFIER, Symbol.EXN_TYPE),
                                        symtab=Symtab.mkTable()})} )
 | HANDLE exn_lst@(env) (COMMA ELSE IDENTIFIER MAPSTO expr@(env) =>
                           ( Absyn.ExnHandler{exnKind=NONE, expr=expr, ty=NONE,
                                              pos=span2pos ELSE_SPAN,
                                              sym=Symbol.toSymbol (IDENTIFIER, Symbol.EXN_TYPE),
                                              symtab=Symtab.mkTable()}
                           )
                        )? END =>
      ( {handlers=exn_lst, default=SR, ty=NONE, pos=span2pos HANDLE_SPAN} );

exn_lst(env):
   single_exn@(env) (COMMA single_exn@(env))* => ( [single_exn] @ SR );

single_exn(env):
   id@(env) IDENTIFIER MAPSTO expr@(env) =>
      ( Absyn.ExnHandler{exnKind=SOME id, expr=expr, pos=span2pos id_SPAN, 
                         sym=Symbol.toSymbol (IDENTIFIER, Symbol.EXN_TYPE),
                         symtab=Symtab.mkTable(), ty=NONE}
      );


(* IDENTIFIERS *)

id(env):
   IDENTIFIER (DOT IDENTIFIER)* => ( Absyn.Id ([IDENTIFIER] @ SR) );

(* FIXME: broken for the list case *)
name_lst(env):
   IDENTIFIER (COMMA IDENTIFIER)* => ( [Symbol.toSymbol (IDENTIFIER, Symbol.VALUE)] );
(*
   IDENTIFIER (COMMA IDENTIFIER)* => ( (Symbol.toSymbol (IDENTIFIER, Symbol.VALUE))::SR );
*)

typed_name_lst(env):
   typed_name@(env) (COMMA typed_name@(env))* => ( [typed_name] @ SR );

typed_name(env):
   IDENTIFIER COLON ty@(env) => ( (Symbol.toSymbol (IDENTIFIER, Symbol.VALUE), ty,
                                   span2pos IDENTIFIER_SPAN) );


(* DECLARATIONS *)

decl(env):
   ABSORB id@(env)   => ( Absyn.Absorb{module=id, pos=span2pos ABSORB_SPAN} )
 | fun_decl@(env)    => ( fun_decl )
 | ty_decl@(env)     => ( ty_decl )
 | val_decl@(env)    => ( val_decl );

fun_decl(env):
   FUNCTION IDENTIFIER LPAREN ty_formals_lst@(env) SEMICOLON formals_lst@(env) RPAREN (COLON ty@(env))? ASSIGN expr@(env) =>
      ( Absyn.FunDecl{sym=Symbol.toSymbol (IDENTIFIER, Symbol.FUN_TYCON), retval=SR,
                      pos=span2pos FUNCTION_SPAN, formals=formals_lst,
                      tyFormals=ty_formals_lst, calls=[], body=expr,
                      symtab=Symtab.mkTable()}
      );

formals_lst(env):
   typed_name_lst@(env)? => ( Option.getOpt (typed_name_lst, []) );

top_decl(env):
   decl@(env)        => ( decl )
 | module_decl@(env) => ( module_decl );

ty_decl(env):
   TYPE IDENTIFIER (LPAREN name_lst@(env) RPAREN)? ASSIGN ty@(env) =>
      ( Absyn.TyDecl{sym=Symbol.toSymbol (IDENTIFIER, Symbol.EXN_TYPE), ty=NONE,
                     absynTy=ty, tyvars=SR, symtab=SOME (Symtab.mkTable()),
                     pos=span2pos TYPE_SPAN}
      );

ty_formals_lst(env):
   name_lst@(env)? => ( Option.getOpt (name_lst, []) );

val_decl(env):
   VAL IDENTIFIER (COLON ty@(env))? ASSIGN expr@(env) =>
      ( Absyn.ValDecl{sym=Symbol.toSymbol (IDENTIFIER, Symbol.VALUE), ty=NONE,
                      absynTy=SR, init=expr, pos=span2pos VAL_SPAN} );


(* TYPES *)

ty(env):
   BOTTOM                                 => ( Absyn.BottomTy (span2pos BOTTOM_SPAN) )
 | EXN LBRACE typed_name_lst@(env) RBRACE => ( Absyn.ExnTy{exn'=typed_name_lst,
                                                           pos=span2pos EXN_SPAN} )
 | id@(env)                               => ( Absyn.IdTy{id=id, pos=span2pos id_SPAN} )
 | LBRACE typed_name_lst@(env) RBRACE     => ( Absyn.RecordTy{record=typed_name_lst,
                                                              pos=span2pos LBRACE_SPAN} )
 | LIST ty@(env)                          => ( Absyn.ListTy{lst=ty,
                                                            pos=span2pos LIST_SPAN} )
 | UNION LBRACE tycon_lst@(env) RBRACE    => ( Absyn.UnionTy{tycons=tycon_lst,
                                                             pos=span2pos UNION_SPAN} );

tycon_lst(env):
   tycon@(env) (COMMA tycon@(env))* => ( [tycon] @ SR );

tycon(env):
   IDENTIFIER (COLON ty@(env))? => ( let val sym = Symbol.toSymbol (IDENTIFIER,
                                                                    Symbol.FUN_TYCON)
                                     in (sym, SR, span2pos IDENTIFIER_SPAN)
                                     end
                                   );
