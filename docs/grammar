/* Grammar for the mitchell language.  No guarantees are made that this
 * grammar is LL(1).  Being that restrictive can mean an awkward grammar,
 * and since I'm not even using a parser generator, I can play as fast and
 * loose as I want with the token lookahead.  So here's the grammar,
 * whatever it may be.
 *
 * $Id: grammar,v 1.3 2004/10/16 22:43:30 chris Exp $
 */

/* mitchell - the bootstrapping compiler
 * Copyright (C) 2004 Chris Lumens
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/* Program-level {{{ */
start ::= module-decl-lst

module-decl ::= MODULE IDENTIFIER ASSIGN DECL proto-lst IN decl-lst END

module-decl-lst ::= module-decl
                  | module-decl module-decl-lst
/* }}} */


/* Expressions {{{ */
expr ::= LBRACK expr-lst RBRACK           /* defines a list */
       | LBRACE record-assn-lst RBRACE    /* defines a record */
       | case-expr
       | decl-expr                        /* creates a new level of scope */
       | if-expr
       | fun-call-or-id
       | INTEGER
       | STRING
       | BOOLEAN

branch-expr ::= id
              | INTEGER
              | STRING
              | BOOLEAN

branch-lst ::= branch-expr MAPSTO expr
             | branch-expr MAPSTO expr COMMA branch-lst

case-expr ::= CASE expr IN branch-lst END

decl-expr ::= DECL decl-lst IN expr END

if-expr ::= IF expr THEN expr ELSE expr

expr-lst ::= expr COMMA expr-lst
           | expr
/* }}} */


/* Declarations {{{ */
decl ::= ty-decl
       | var-decl
       | const-decl
       | fun-decl

decl-lst ::= decl decl-lst
           | decl

proto ::= ty-decl-proto
        | var-decl-proto
        | const-decl-proto
        | fun-decl-proto

proto-lst ::= proto
            | proto proto-lst
/* }}} */


/* Types {{{ */
ty-decl-proto ::= TYPE id

single-ty ::= LBRACK id-lst RBRACK
            | id

ty-decl ::= ty-decl-proto ASSIGN ty

ty ::= single-ty
     | single-ty LIST                     /* defines a list of type ty */

id-lst ::= IDENTIFIER COLON ty
         | IDENTIFIER COLON ty COMMA id-lst

record-assn-lst ::= IDENTIFIER ASSIGN expr
                  | IDENTIFIER ASSIGN expr COMMA record-assn-lst
/* }}} */


/* Variables {{{ */
var-decl-proto ::= VAR IDENTIFIER COLON ty

var-decl ::= var-decl-proto ASSIGN expr

id ::= IDENTIFIER
     | IDENTIFIER DOT id
/* }}} */


/* Constants {{{ */
const-decl-proto ::= CONST IDENTIFIER COLON ty

const-decl ::= const-decl-proto ASSIGN expr
/* }}} */


/* Functions {{{ */
fun-decl-proto ::= FUNCTION IDENTIFIER COLON ty LPAREN id-lst RPAREN
                 | FUNCTION IDENTIFIER COLON ty LPAREN RPAREN

fun-decl ::= fun-decl-proto ASSIGN expr

fun-call-or-id ::= id LPAREN expr-lst RPAREN
                 | id LPAREN RPAREN
                 | id
/* }}} */


/* Terminals {{{ */
ASSIGN ::= ←

BOOLEAN ::= t
          | f

CASE ::= case

COLON ::= :

COMMA ::= ,

CONST ::= ɕ

DECL ::= decl

DOT ::= .

ELSE ::= else

END ::= end

FUNCTION ::= ƒ

IDENTIFIER ::= [^←:,.ƒ[(])τ \t\n][^ \t\n]*

IF ::= if

IN ::= in

INTEGER ::= [0-9]+

LBRACE ::= {

LBRACK ::= [

LIST ::= list

LPAREN ::= (

MAPSTO ::= →

MODULE ::= ℳ

RBRACE ::= }

RBRACK ::= ]

RPAREN ::= )

STRING ::= ".*"

THEN ::= then

TYPE ::= τ

VAR ::= ʋ
/* }}} */
