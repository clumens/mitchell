/* EBNF for the mitchell language.  No guarantees are made that this grammar
 * is LL(1).  Being that restrictive can mean an awkward grammar, and since
 * I'm not even using a parser generator, I can play as fast and loose as I
 * want with the token lookahead.  So here's the grammar, whatever it may be.
 */

/* mitchell - the bootstrapping compiler
 * Copyright (C) 2004-2006 Chris Lumens
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/* Program-level */
start = module-decl+

module-decl = module-symbol identifier-symbol assign-symbol decl-symbol top-decl+ end-symbol


/* Expressions */
expr = lparen-symbol base-expr rparen-symbol (handle-symbol exn-lst end-symbol)?
     | base-expr (handle-symbol exn-lst end-symbol)?

expr-lst = expr (comma-symbol expr)*

base-expr = record-literal
          | lbrack-symbol expr-lst? rbrack-symbol
          | case-expr
          | decl-expr
          | if-expr
          | sym-ref
          | raise-symbol expr
          | integer-symbol
          | string-symbol
          | boolean-symbol
          | bottom-symbol

branch-lst = branch-expr mapsto-symbol expr (comma-symbol branch-lst)?

branch-expr = id
            | id lparen-symbol name-lst? rparen-symbol
            | integer-symbol
            | string-symbol
            | boolean-symbol

case-expr = case-symbol expr in-symbol branch-lst (comma-symbol else-symbol mapsto-symbol expr)? end-symbol

decl-expr = decl-symbol decl+ in-symbol expr end-symbol

exn-lst = id identifier-symbol mapsto-symbol expr (comma-symbol exn-lst)?
        | else-symbol identifier-symbol mapsto-symbol expr

if-expr = if-symbol expr then-symbol expr else-symbol expr

record-literal = lbrace-symbol record-assn-lst rbrace-symbol


/* Declarations */
decl = ty-decl
     | val-decl
     | fun-decl
     | absorb-symbol id

top-decl = decl
         | module-decl


/* Types */
ty-decl = type-symbol identifier-symbol (lparen-symbol name-lst rparen-symbol)? assign-symbol ty

ty = bottom-symbol
   | list-symbol ty
   | exn-symbol lbrace-symbol typed-name-lst rbrace-symbol
   | union-symbol lbrace-symbol tycon-lst rbrace-symbol
   | lbrace-symbol typed-name-lst rbrace-symbol
   | id

ty-lst = ty (comma-symbol ty)*

tycon-lst = identifier-symbol (colon-symbol ty)? (comma-symbol tycon-lst)*

typed-name-lst = identifier-symbol colon-symbol ty (comma-symbol identifier-symbol colon-symbol ty)*

name-lst = identifier-symbol (comma-symbol identifier-symbol)*

record-assn-lst = identifier-symbol assign-symbol expr (comma-symbol record-assn-lst)*


/* Values */
val-decl = val-symbol identifier-symbol (colon-symbol ty)? assign-symbol expr

id = identifier-symbol (dot-symbol identifier-symbol)*

record-ref = (pipe-symbol identifier-symbol)+


/* Functions */
fun-decl = function-symbol identifier-symbol lparen-symbol ty-formals-lst semicolon-symbol formals-lst rparen-symbol (colon-symbol ty)? assign-symbol expr

ty-formals-lst = name-lst?

formals-lst = typed-name-lst?

sym-ref = id
        | id lparen-symbol ty-lst? semicolon-symbol expr-lst? rparen-symbol
        | sym-ref record-ref
        | id record-literal


/* Misc */
comment = start-comment-symbol .* end-comment-symbol


/* Terminals */
absorb-symbol = "absorb"

assign-symbol = "←"

boolean-symbol = "t" | "f"

bottom-symbol = "⊥"

case-symbol = "case"

colon-symbol = ":"

comma-symbol = ","

decl-symbol = "decl"

dot-symbol = "."

else-symbol = "else"

end-symbol = "end"

end-comment-symbol = "\n"

exn-symbol = "ℰ"

function-symbol = "ƒ"

handle-symbol = "handle"

if-symbol = "if"

in-symbol = "in"

integer-symbol = [0-9]+

lbrace-symbol = "{"

lbrack-symbol = "["

list-symbol = "list"

lparen-symbol = "("

mapsto-symbol = "→"

module-symbol = "ℳ"

pipe-symbol = "|"

raise-symbol = "raise"

rbrace-symbol = "}"

rbrack-symbol = "]"

rparen-symbol = ")"

semicolon-symbol = ";"

start-comment-symbol = "#"

string-symbol = ".*"

then-symbol = "then"

type-symbol = "τ"

union-symbol = "∪"

val-symbol = "ʋ"
