/* Grammar for the mitchell language.  No guarantees are made that this
 * grammar is LL(1).  Being that restrictive can mean an awkward grammar,
 * and since I'm not even using a parser generator, I can play as fast and
 * loose as I want with the token lookahead.  So here's the grammar,
 * whatever it may be.
 *
 * $Id: grammar,v 1.17 2005/03/29 05:52:43 chris Exp $
 */

/* mitchell - the bootstrapping compiler
 * Copyright (C) 2004 Chris Lumens
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/* Program-level {{{ */
start ::= module-decl-lst

module-decl ::= MODULE IDENTIFIER ASSIGN DECL top-decl-lst END

module-decl-lst ::= module-decl
                  | module-decl module-decl-lst
/* }}} */


/* Expressions {{{ */
expr ::= LPAREN naked-expr RPAREN
       | LPAREN naked-expr RPAREN exn-handler
       | naked-expr
       | naked-expr exn-handler

naked-expr ::= LBRACK expr-lst RBRACK
             | LBRACE record-assn-lst RBRACE
             | case-expr
             | decl-expr
             | if-expr
             | sym-ref
             | RAISE expr
             | INTEGER
             | STRING
             | BOOLEAN
             | BOTTOM

branch-expr ::= id
              | INTEGER
              | STRING
              | BOOLEAN

branch-lst ::= branch-expr MAPSTO expr
             | branch-expr MAPSTO expr COMMA branch-lst
             | ELSE MAPSTO expr

case-expr ::= CASE expr IN branch-lst END

if-expr ::= IF expr THEN expr ELSE expr

expr-lst ::= expr COMMA expr-lst
           | expr

exn-lst ::= id IDENTIFIER MAPSTO expr
          | id IDENTIFIER MAPSTO expr COMMA exn-lst
          | ELSE IDENTIFIER MAPSTO expr

exn-handler ::= HANDLE exn-lst END
/* }}} */


/* Declarations {{{ */
decl ::= ty-decl
       | val-decl
       | fun-decl

decl-lst ::= decl decl-lst
           | decl

top-decl ::= decl
           | module-decl

top-decl-lst ::= top-decl top-decl-lst
               | top-decl

decl-expr ::= DECL decl-lst IN expr END
/* }}} */


/* Types {{{ */
ty-decl ::= TYPE IDENTIFIER ASSIGN ty

ty ::= BOTTOM
     | EXN LBRACE id-lst RBRACE
     | LIST ty
     | LBRACE id-lst RBRACE
     | id

id-lst ::= IDENTIFIER COLON ty
         | IDENTIFIER COLON ty COMMA id-lst

record-assn-lst ::= IDENTIFIER ASSIGN expr
                  | IDENTIFIER ASSIGN expr COMMA record-assn-lst
/* }}} */


/* Values {{{ */
val-decl ::= VAL IDENTIFIER COLON ty ASSIGN expr

id ::= IDENTIFIER
     | IDENTIFIER DOT id

record-ref ::= PIPE IDENTIFIER
             | PIPE IDENTIFIER record-ref
/* }}} */


/* Functions {{{ */
fun-decl ::= FUNCTION IDENTIFIER COLON ty LPAREN id-lst RPAREN ASSIGN expr
           | FUNCTION IDENTIFIER COLON ty LPAREN RPAREN ASSIGN expr

arg-lst ::= LPAREN RPAREN
          | LPAREN expr-lst RPAREN

sym-ref ::= id
          | id record-ref
          | id arg-lst
          | id arg-lst record-ref
          | id LBRACE record-assn-lst RBRACE
/* }}} */

/* Terminals {{{ */
ASSIGN ::= ←

BOOLEAN ::= t
          | f

BOTTOM ::= ⊥

CASE ::= case

COLON ::= :

COMMA ::= ,

DECL ::= decl

DOT ::= .

ELSE ::= else

END ::= end

EXN ::= ℰ

FUNCTION ::= ƒ

HANDLE ::= handle

IF ::= if

IN ::= in

INTEGER ::= [0-9]+

LBRACE ::= {

LBRACK ::= [

LIST ::= list

LPAREN ::= (

MAPSTO ::= →

MODULE ::= ℳ

PIPE ::= |

RAISE ::= raise

RBRACE ::= }

RBRACK ::= ]

RPAREN ::= )

STRING ::= ".*"

THEN ::= then

TYPE ::= τ

VAL ::= ʋ
/* }}} */
