/* Grammar for the mitchell language.  No guarantees are made that this
 * grammar is LL(1).  Being that restrictive can mean an awkward grammar,
 * and since I'm not even using a parser generator, I can play as fast and
 * loose as I want with the token lookahead.  So here's the grammar,
 * whatever it may be.
 *
 * $Id: grammar,v 1.13 2004/12/22 02:06:18 chris Exp $
 */

/* mitchell - the bootstrapping compiler
 * Copyright (C) 2004 Chris Lumens
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/* Program-level {{{ */
start ::= module-decl-lst

module-decl ::= MODULE IDENTIFIER ASSIGN DECL top-decl-lst END

module-decl-lst ::= module-decl
                  | module-decl module-decl-lst
/* }}} */


/* Expressions {{{ */
expr ::= LBRACK expr-lst RBRACK
       | LBRACE record-assn-lst RBRACE
       | case-expr
       | decl-expr
       | if-expr
       | fun-call-or-id
       | INTEGER
       | STRING
       | BOOLEAN

branch-expr ::= id
              | INTEGER
              | STRING
              | BOOLEAN

branch-lst ::= ELSE MAPSTO expr
             | branch-expr MAPSTO expr
             | branch-expr MAPSTO expr COMMA branch-lst

case-expr ::= CASE expr IN branch-lst END

if-expr ::= IF expr THEN expr ELSE expr

expr-lst ::= expr COMMA expr-lst
           | expr
/* }}} */


/* Declarations {{{ */
decl ::= ty-decl
       | val-decl
       | fun-decl

decl-lst ::= decl decl-lst
           | decl

top-decl ::= decl
           | module-decl

top-decl-lst ::= top-decl top-decl-lst
               | top-decl

decl-expr ::= DECL decl-lst IN expr END
/* }}} */


/* Types {{{ */
ty-decl ::= TYPE IDENTIFIER ASSIGN ty

ty ::= LIST ty
     | LBRACE id-lst RBRACE
     | id

id-lst ::= IDENTIFIER COLON ty
         | IDENTIFIER COLON ty COMMA id-lst

record-assn-lst ::= IDENTIFIER ASSIGN expr
                  | IDENTIFIER ASSIGN expr COMMA record-assn-lst
/* }}} */


/* Values {{{ */
val-decl ::= VAL IDENTIFIER COLON ty ASSIGN expr

id ::= IDENTIFIER
     | IDENTIFIER DOT id

record-ref ::= IDENTIFIER PIPE record-ref
             | IDENTIFIER
/* }}} */


/* Functions {{{ */
fun-decl ::= FUNCTION IDENTIFIER COLON ty LPAREN id-lst RPAREN ASSIGN expr
           | FUNCTION IDENTIFIER COLON ty LPAREN RPAREN ASSIGN expr

fun-call-or-id ::= id LPAREN expr-lst RPAREN
                 | id LPAREN RPAREN
                 | id PIPE record-ref
                 | id
/* }}} */


/* Terminals {{{ */
ASSIGN ::= ←

BOOLEAN ::= t
          | f

CASE ::= case

COLON ::= :

COMMA ::= ,

DECL ::= decl

DOT ::= .

ELSE ::= else

END ::= end

FUNCTION ::= ƒ

IF ::= if

IN ::= in

INTEGER ::= [0-9]+

LBRACE ::= {

LBRACK ::= [

LIST ::= list

LPAREN ::= (

MAPSTO ::= →

MODULE ::= ℳ

PIPE ::= |

RBRACE ::= }

RBRACK ::= ]

RPAREN ::= )

STRING ::= ".*"

THEN ::= then

TYPE ::= τ

VAL ::= ʋ
/* }}} */
