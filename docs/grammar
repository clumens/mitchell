/* Grammar for the mitchell language.  No guarantees are made that this
 * grammar is LL(1).  Being that restrictive can mean an awkward grammar,
 * and since I'm not even using a parser generator, I can play as fast and
 * loose as I want with the token lookahead.  So here's the grammar,
 * whatever it may be.
 *
 * $Id: grammar,v 1.19 2005/07/08 17:32:23 chris Exp $
 */

/* mitchell - the bootstrapping compiler
 * Copyright (C) 2004 Chris Lumens
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/* Program-level */
start ::= module-decl-lst

module-decl ::= MODULE IDENTIFIER ASSIGN DECL top-decl-lst END

module-decl-lst ::= module-decl
                  | module-decl module-decl-lst


/* Expressions */
expr ::= LPAREN base-expr RPAREN
       | LPAREN base-expr RPAREN HANDLE exn-lst END
       | base-expr
       | base-expr HANDLE exn-lst END

base-expr ::= LBRACE record-assn-lst RBRACE
            | list-expr
            | CASE expr IN branch-lst END
            | DECL decl-lst IN expr END
            | IF expr THEN expr ELSE expr
            | sym-ref
            | RAISE expr
            | INTEGER
            | STRING
            | BOOLEAN
            | BOTTOM

list-expr ::= LBRACK RBRACK
            | LBRACK expr-lst RBRACK

branch-lst ::= branch-expr MAPSTO expr
             | branch-expr MAPSTO expr COMMA branch-lst
             | ELSE MAPSTO expr

branch-expr ::= id
              | id LPAREN RPAREN
              | id LPAREN name-lst RPAREN
              | INTEGER
              | STRING
              | BOOLEAN

expr-lst ::= expr COMMA expr-lst
           | expr

exn-lst ::= id IDENTIFIER MAPSTO expr
          | id IDENTIFIER MAPSTO expr COMMA exn-lst
          | ELSE IDENTIFIER MAPSTO expr


/* Declarations */
decl ::= ty-decl
       | val-decl
       | fun-decl

decl-lst ::= decl decl-lst
           | decl

top-decl ::= decl
           | module-decl

top-decl-lst ::= top-decl top-decl-lst
               | top-decl


/* Types */
ty-decl ::= TYPE IDENTIFIER ASSIGN ty

ty ::= BOTTOM
     | LIST ty
     | EXN LBRACE typed-name-lst RBRACE
     | UNION LBRACE tycon-lst RBRACE
     | LBRACE typed-name-lst RBRACE
     | id

tycon-lst ::= IDENTIFIER COLON ty
            | IDENTIFIER COLON ty COMMA tycon-lst
            | IDENTIFIER
            | IDENTIFIER COMMA tycon-lst

typed-name-lst ::= IDENTIFIER COLON ty
                 | IDENTIFIER COLON ty COMMA typed-name-lst

name-lst ::= IDENTIFIER
           | IDENTIFIER COMMA name-lst

record-assn-lst ::= IDENTIFIER ASSIGN expr
                  | IDENTIFIER ASSIGN expr COMMA record-assn-lst


/* Values */
val-decl ::= VAL IDENTIFIER COLON ty ASSIGN expr
           | VAL IDENTIFIER ASSIGN expr

id ::= IDENTIFIER
     | IDENTIFIER DOT id

record-ref ::= PIPE IDENTIFIER
             | PIPE IDENTIFIER record-ref


/* Functions */
fun-decl ::= FUNCTION IDENTIFIER COLON ty formals-lst ASSIGN expr
           | FUNCTION IDENTIFIER formals-lst ASSIGN expr

formals-lst ::= LPAREN RPAREN
              | LPAREN typed-name-lst RPAREN

arg-lst ::= LPAREN RPAREN
          | LPAREN expr-lst RPAREN

sym-ref ::= id
          | id arg-lst
          | sym-ref record-ref
          | id LBRACE record-assn-lst RBRACE


/* Terminals */
ASSIGN ::= ←

BOOLEAN ::= t
          | f

BOTTOM ::= ⊥

CASE ::= case

COLON ::= :

COMMA ::= ,

DECL ::= decl

DOT ::= .

ELSE ::= else

END ::= end

EXN ::= ℰ

FUNCTION ::= ƒ

HANDLE ::= handle

IF ::= if

IN ::= in

INTEGER ::= [0-9]+

LBRACE ::= {

LBRACK ::= [

LIST ::= list

LPAREN ::= (

MAPSTO ::= →

MODULE ::= ℳ

PIPE ::= |

RAISE ::= raise

RBRACE ::= }

RBRACK ::= ]

RPAREN ::= )

STRING ::= ".*"

THEN ::= then

TYPE ::= τ

UNION ::= ∪

VAL ::= ʋ
