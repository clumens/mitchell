/* Type checking rules for the Mitchell language.  This document describes
 * how a conformant mitchell compiler will perform type checking on a
 * program.  The exact rules are provided in the first section, while
 * explanation and examples are provided in the second.  In the event of
 * any discrepancy between the rules and the explanation, the rules are
 * always correct.
 *
 * $Id: typing,v 1.5 2005/01/05 03:14:13 chris Exp $
 */

/* mitchell - the bootstrapping compiler
 * Copyright (C) 2004 Chris Lumens
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

Typing Rules
============
⊢ t : boolean     [true-expr]
⊢ f : boolean     [false-expr]
⊢ integer-constant : integer     [integer]
⊢ string-constant : string     [string]

A[I : T] ⊢ I : T     [id]  

      ∀i . (A ⊢ Ei : T)
----------------------------     [list]
A ⊢ [ E1, ..., En ] : T list

                          ∀i . (A ⊢ Ei : Ti)
-----------------------------------------------------------------     [record]
A ⊢ { I1 ← E1: T1, ..., In ← En: Tn } : { I1 : T1, ..., In : Tn }

                     A ⊢ Et : Tt 
                 ∀i . (A ⊢ Ebi : Tt) 
                  ∀i . (A ⊢ Ei : T)
-----------------------------------------------------     [case-expr-1]
   A ⊢ case Et in Eb1 → E1, ..., Ebn → En end : T

                         A ⊢ Et : Tt
                     ∀i . (A ⊢ Ebi : Tt) 
                      ∀i . (A ⊢ Ei : T) 
                         A ⊢ Ee : T
------------------------------------------------------------     [case-expr-2]
   A ⊢ case Et in Eb1 → E1, ..., Ebn → En, else → Ee end : T

      A' = A[I1 : T1, ..., In : Tn]
           ∀i . (A' ⊢ Ii : Ti)
               A' ⊢ E : Te
------------------------------------------     [decl-expr]
A ⊢ decl I1: T1, ..., In: Tn in E end : Te

A ⊢ E1 : boolean ; A ⊢ E2 : T ; A ⊢ E3 : T
------------------------------------------     [if-expr]
       A ⊢ if E1 then E2 else E3 : T

A ⊢ Ip : ⊥ → Tb
---------------     [call-empty]
A ⊢ Ip () : Tb

A ⊢ Ip : (T1, ..., Tn) → Tb
    ∀i . (A ⊢ Ei : Ti)
---------------------------     [call-args]
 A ⊢ Ip (E1, ..., En) : Tb

            A[I1 : T1, ..., In : Tn] ⊢ Eb : Tb
------------------------------------------------------------     [fun-decl]
A ⊢ ƒ If: Tb (I1: T1, ..., In: Tn) ← Eb : (T1, ..., Tn) → Tb


Type Equivalence Rules
======================
T = T    [reflexive-=]

T1 = T2
-------    [symmetric-=]
T2 = T1

T1 = T2 ; T2 = T3
-----------------     [transitive-=]
     T1 = T3

     T1 = T2
-----------------     [list-=]
T1 list = T2 list

τ I ← T list = τ Inew ← [Inew/I]T list     [list-α]

           { Nl1, ..., Nln } = { Nr1, ..., Nrn }
              ∀i, j . (Nlj = Nri ⇒ Tlj = Tri)
-----------------------------------------------------------     [record-=]
{Nl1 : Tl1, ..., Nln : Tln } = {Nr1 : Tr1, ..., Nrn : Trn }

τ I ← { N1, ..., Nn } = τ Inew ← [Inew/I]{ N1, ..., Nn }     [record-α]


Notes
=====
[list-=] states that two list types are equivalent if the underlying types
are equivalent.  That is, the following list types are equivalent:

   * integer list = integer list
   * string list list = string list list

However, the following list types are not:

   * boolean list ≠ integer list
   * integer list ≠ integer list list


[list-α] states that two list type definitions produce equivalent types
even if they have different type names, as long as the underlying types
are equivalent subject to [list-=].  That is, the following list
definitions are equivalent:

   * τ lst ← string list = τ str_lst ← string list


[record-=] states that two record types are equivalent if the have the
same named elements with equivalent types.  However, the elements can be
listed in any order and still preserve equivalence.  That is, the
following record types are equivalent:

   * { name: string } = { name: string }
   * { make: string, model: string, year: integer } =
        { make: string, model: string, year: integer }
   * { name: string, age: integer } = { age: integer, name: string }

However, the following record types are not:

   * { name: string } ≠ { age: integer }
   * { make: string } ≠ { model: string }
   * { year: string } ≠ { year: integer }


[record-α] states that two record type definitions produce equivalent
types even if they have different type names, as long as the underlying
types are equivalent subject to [record-=].  That is, the following record
definitions are equivalent:

   * τ car ← { make: string, model: string } =
        τ vehicle ← { make: string, model: string }


Name Scope
==========
Mitchell is a lexically-scoped language with nested modules, providing
different namespaces for types, module names, and functions/values.
Modules may further contain other modules.  A module's symbol table exists
for the entire lifetime of the program, while the symbol table for a
function or decl block only exists while that local block is being type
checked.  Lexically scoped means that symbol names are resolved against
the environment they were defined in, rather than the environment they
were called from.

At the top level, there is an implicit layer of scope that contains all
the base types and identifiers, as well as all modules that are not
declared inside another module.  This layer also contains the base types -
integer, boolean, string, and so on.  So, the modules of the standard
library would exist inside this top-level scope, as would the modules that
make up the main modules of a program.  With the exception of a
potentially large collection of modules, the top-level environment is very
small.

The rules for resolving names are unfortunately a little more complicated
than they should be.  The module system is partially to blame for the
complications.  The rules are as follows:

   * If a "naked identifier" is given (that is, without multiple
     period-delimited sections indicating module references) then it is
     assumed to exist somewhere within the lexically innermost module.
     This environment consists of all the identifiers defined at the
     module's top level, plus all the modifications made to the
     environment to take into account any functions or decl blocks the
     reference may occur in.  This environment is searched from the
     innermost scope to the module's top level.  At this point if the
     symbol is not found, it is an unresolved reference.  Resolution of a
     naked identifier does not jump out of the current module.

     As a special exception to this rule, the global namespace will be
     searched next in order to handle the base types.  This currently
     allows the base types to be redefined.  It's not yet decided whether
     that should be allowed behavior or not.

   * If an identifier is given that consists of period-delimited names, it
     must be referring to a symbol defined in a module.  The entire path
     from the lexically outermost module all the way to the one containing
     the symbol must be referenced, or the symbol will be unresolved.
     That is, the identifier is resolved relative to the global symbol
     table going downwards.

   * Within a block of declarations, new type and function declarations
     may reference other types and functions that are not yet defined.
     This is to allow recursive declarations for tree structures,
     recursive functions, and so forth.  However, restrictions are placed
     on how this works.  A group of type declarations is defined as
     several type declarations with no value, function, or module
     declarations.  A group of function declarations is defined similarly.

     In a group of type declarations, any type may refer to any other type
     in the group, to allow for recursive definitions.  However, all types
     must be resolved at the end of the group.  Similarly, in a group of
     function declarations, any function may refer to any other function
     in the group.

   * Values may not make reference to values that are not yet defined.
